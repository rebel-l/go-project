{{define "package.go"}}// Package bootstrap provides custom initialisation functions to be called from main on startup
package bootstrap
{{end}}

{{define "database.go"}}package bootstrap

import (
    "fmt"
    "path/filepath"

    // "github.com/rebel-l/branma_be/config" // TODO: goimports is doing the job?

    "github.com/rebel-l/schema"

    "github.com/jmoiron/sqlx"

    "github.com/rebel-l/go-utils/osutils"
)

const (
    storageFileName = "{{.GetProjectName}}.db"
)

// Database initialises the database and returns the connection
func Database(conf *config.Database, version string, withBar bool) (*sqlx.DB, error) {
    fileName, err := createStorage(conf.GetStoragePath())
    if err != nil {
        return nil, fmt.Errorf("bootstrap database, create storage failed: %v", err)
    }

    db, err := open(fileName)
    if err != nil {
        return nil, fmt.Errorf("bootstrap database, open database failed: %w", err)
    }

    err = createSchema(db, conf.GetSchemaScriptPath(), version, withBar)
    if err != nil {
        return nil, fmt.Errorf("bootstrap database, create schema failed: %w", err)
    }

    _, err = db.Exec("PRAGMA foreign_keys = ON;")
    if err != nil {
        return nil, fmt.Errorf("bootstrap database, activate foreign key checks failed: %w", err)
    }

    return db, nil
}

func createStorage(path string) (string, error) {
    if err := osutils.CreateDirectoryIfNotExists(path); err != nil {
        return "", err
    }

    fileName := buildFileName(path)
    if err := osutils.CreateFileIfNotExists(fileName); err != nil {
        return "", err
    }

    return fileName, nil
}

func createSchema(db *sqlx.DB, scriptPath, version string, withBar bool) error {
    s := schema.New(db)
    if withBar {
        s.WithProgressBar()
    }

    return s.Upgrade(scriptPath, version)
}

func open(fileName string) (*sqlx.DB, error) {
    db, err := sqlx.Open("sqlite3", fileName)
    return db, err
}

func buildFileName(path string) string {
    return filepath.Join(path, storageFileName)
}

// DatabaseReset resets the whole database. NOTE: all data will be lost, should be used only for development.
func DatabaseReset(conf *config.Database, withBar bool) error {
    fileName := buildFileName(conf.GetStoragePath())

    db, err := open(fileName)
    if err != nil {
        return fmt.Errorf("bootstrap database reset, open database failed: %w", err)
    }

    defer func() {
        _ = db.Close()
    }()

    s := schema.New(db)
    if withBar {
        s.WithProgressBar()
    }

    err = s.RevertAll(conf.GetSchemaScriptPath())
    if err != nil {
        return fmt.Errorf("bootstrap database reset, revert database failed: %w", err)
    }

    return nil
}
{{end}}

{{define "database_test.go"}}package bootstrap_test

import (
    "os"
    "path/filepath"
    "testing"

    _ "github.com/mattn/go-sqlite3"

    "github.com/rebel-l/go-utils/slice"
    "github.com/rebel-l/go-utils/osutils"
)

func setup(t *testing.T, name string) *config.Database {
    t.Helper()

    // 1. config
    storagePath := filepath.Join(".", "..", "storage", name)
    scriptPath := filepath.Join(".", "..", "scripts", "sql", "sqlite") // TODO: change that it works with other dialects like postgres
    conf := &config.Database{
        StoragePath:       &storagePath,
        SchemaScriptsPath: &scriptPath,
    }

    // 2. clean up
    if osutils.FileOrPathExists(conf.GetStoragePath()) {
        if err := os.RemoveAll(conf.GetStoragePath()); err != nil {
            t.Fatalf("failed to cleanup test files: %v", err)
        }
    }

    return conf
}

func TestDatabase(t *testing.T) {
    if testing.Short() {
        t.Skip("long running test")
    }

    fixtures := slice.StringSlice{  // TODO: where to get this list of tables from?
        "schema_script",
        "sqlite_sequence",
        "{{.GetSQlTableName}}",
    }

    // 1. setup
    conf := setup(t, "test_bootstrap")

    // 2. do the test
    db, err := bootstrap.Database(conf, "0.0.0", false)
    if err != nil {
        t.Fatalf("No error expected: %v", err)
    }

    defer func() {
        if err = db.Close(); err != nil {
            t.Fatalf("unable to close database connection: %v", err)
        }
    }()

    // 3. do the assertions
    var tables slice.StringSlice

    q := db.Rebind("SELECT name FROM sqlite_master WHERE type='table';")

    if err = db.Select(&tables, q); err != nil {
        t.Fatalf("failed to list tables: %v", err)
    }

    if !fixtures.IsEqual(tables) {
        t.Errorf("tables are not created, expected: '%v' | got: '%v'", fixtures, tables)
    }
}

func TestDatabaseReset(t *testing.T) {
    if testing.Short() {
        t.Skip("long running test")
    }

    fixtures := slice.StringSlice{
        "schema_script",
        "sqlite_sequence",
    }

    // 1. setup
    conf := setup(t, "test_reset")

    // 2. do the test
    db, err := bootstrap.Database(conf, "0.0.0", false)
    if err != nil {
        t.Fatalf("No error expected on bbotstrap: %v", err)
    }

    defer func() {
        if err = db.Close(); err != nil {
            t.Fatalf("unable to close database connection: %v", err)
        }
    }()

    if err = bootstrap.DatabaseReset(conf, false); err != nil {
        t.Fatalf("No error expected on reset: %v", err)
    }

    // 3. do the assertions
    var tables slice.StringSlice

    q := db.Rebind("SELECT name FROM sqlite_master WHERE type='table';")

    if err = db.Select(&tables, q); err != nil {
        t.Fatalf("failed to list tables: %v", err)
    }

    if !fixtures.IsEqual(tables) {
        t.Errorf("tables are not reseted, expected: '%v' | got: '%v'", fixtures, tables)
    }
}
{{end}}
