{{define "package.go"}}// Package {{.Name | ToLower}}store contains the CRUD operations for the {{.GetSQlTableName}} on the database.
package {{.Name | ToLower}}store
{{end}}

{{define "store.go"}}{{$elems := .Attributes}}package {{.Name | ToLower}}store

import (
    "context"
    "errors"
    "time"

    "github.com/jmoiron/sqlx"
    {{range $p := .GetPackages}}"{{$p}}"{{end}}
)

var (
    // ErrIDMissing will be thrown if an ID is expected but not set.
    ErrIDMissing = errors.New("id is mandatory for this operation")

    {{if .IsIDUUID -}}// ErrCreatingID will be thrown if creating an ID failed.
    ErrCreatingID = errors.New("id creation failed"){{end}}

    // ErrIDIsSet will be thrown if no ID is expected but already set.
    ErrIDIsSet = errors.New("id should be not set for this operation, use update instead")

    // ErrDataMissing will be thrown if mandatory data is not set.
    ErrDataMissing = errors.New("no data or mandatory data missing")
)

// {{.Name}} represents the {{.Name | ToLower}} in the database.
type {{.Name}} struct {
{{- range $elem := $elems}}
    {{$elem.GetStoreField}}
{{- end}}
    CreatedAt  time.Time `db:"created_at"`
    ModifiedAt time.Time `db:"modified_at"`
}

// Create creates current object in the database.
func ({{.GetReceiver}} *{{.Name}}) Create(ctx context.Context, db *sqlx.DB) error {
    if !{{.GetReceiver}}.IsValid() {
        return ErrDataMissing
    }

    {{if .IsIDUUID -}}
    if {{.GetReceiver}}.ID.String() != "" {
        return ErrIDIsSet
    }

    var err error
    {{.GetReceiver}}.ID, err = uuid.NewRandom() // TODO: maybe create a hash based on struct data
    if err != nil {
        return fmt.Errorf("%w: %v", ErrCreatingID, err)
    }

    {{else -}}
    if {{.GetReceiver}}.ID != 0 {
        return ErrIDIsSet
    }

    {{end -}}

    q := db.Rebind(`{{.GetSQLInsert}}`)

    {{.GetExecInsert}}
    if err != nil {
        return err
    }

    {{if not .IsIDUUID -}}
    id, err := res.LastInsertId()
    if err != nil {
        return err
    }

    {{.GetReceiver}}.ID = int(id) // TODO: use int64 to avoid type conversion

    {{end -}}

    return {{.GetReceiver}}.Read(ctx, db)
}

// Read sets the {{.Name | ToLower}} from database by given ID.
func ({{.GetReceiver}} *{{.Name}}) Read(ctx context.Context, db *sqlx.DB) error {
    if {{.GetReceiver}} == nil || {{.GetIDEmptyComparison}} {
        return ErrIDMissing
    }

    q := db.Rebind(`SELECT {{.Attributes.GetSQLFieldNames}}, created_at, modified_at FROM {{.GetSQlTableName}} WHERE id = ?`)

    return db.GetContext(ctx, {{.GetReceiver}}, q, {{.GetReceiver}}.ID)
}

// Update changes the current object on the database by ID.
func ({{.GetReceiver}} *{{.Name}}) Update(ctx context.Context, db *sqlx.DB) error {
    if !{{.GetReceiver}}.IsValid() {
        return ErrDataMissing
    }

    if {{.GetIDEmptyComparison}} {
        return ErrIDMissing
    }

    q := db.Rebind(`{{.GetSQLUpdate}}`)

    if _, err := db.ExecContext(ctx, q, {{.GetStructFieldsWithIDLast}}); err != nil {
        return err
    }

    return {{.GetReceiver}}.Read(ctx, db)
}

// Delete removes the current object from database by its ID.
func ({{.GetReceiver}} *{{.Name}}) Delete(ctx context.Context, db *sqlx.DB) error {
    if {{.GetReceiver}} == nil || {{.GetIDEmptyComparison}} {
        return ErrIDMissing
    }

    q := db.Rebind(`DELETE FROM {{.GetSQlTableName}} WHERE id = ?`)

    _, err := db.ExecContext(ctx, q, {{.GetReceiver}}.ID)

    return err
}

// IsValid returns true if all mandatory fields are set.
func ({{.GetReceiver}} *{{.Name}}) IsValid() bool {
    if {{.GetReceiver}} == nil || {{.GetValidationWithoutID}} {
        return false
    }

    return true
}
{{end}}

{{define "store_test.go"}}package {{.Name | ToLower}}store_test

import (
    "context"
    "database/sql"
    "errors"
    "os"
    "path/filepath"
    "testing"
    "time"

    "github.com/jmoiron/sqlx"
    _ "github.com/mattn/go-sqlite3"

    // "github.com/rebel-l/branma_be/{{.Name | ToLower}}/{{.Name | ToLower}}store" // TODO: goimports is doing the job?
    "github.com/rebel-l/go-utils/osutils"
)

func setup(t *testing.T, name string) *sqlx.DB {
    t.Helper()

    // 0. init path
    storagePath := filepath.Join(".", "..", "..", "storage", "test_{{.Name | ToLower}}", name)
    scriptPath := filepath.Join(".", "..", "..", "scripts", "sql", "sqlite") // TODO: change that it works with other dialects like postgres
    conf := &config.Database{
        StoragePath:       &storagePath,
        SchemaScriptsPath: &scriptPath,
    }

    // 1. clean up
    if osutils.FileOrPathExists(conf.GetStoragePath()) {
        if err := os.RemoveAll(conf.GetStoragePath()); err != nil {
            t.Fatalf("failed to cleanup test files: %v", err)
        }
    }

    // 2. init database
    db, err := bootstrap.Database(conf, "0.0.0")
    if err != nil {
        t.Fatalf("No error expected: %v", err)
    }

    return db
}

func Test{{.Name}}_Create(t *testing.T) { // nolint:funlen
    if testing.Short() {
        t.Skip("long running test")
    }

    // 1. setup
    db := setup(t, "storeCreate")

    defer func() {
        if err := db.Close(); err != nil {
            t.Fatalf("unable to close database connection: %v", err)
        }
    }()

    // 2. test
    testCases := []struct {
        name        string
        actual      *{{.Name | ToLower}}store.{{.Name}}
        expected    *{{.Name | ToLower}}store.{{.Name}}
        expectedErr error
    }{
        {
            name:        "{{.Name | ToLower}} is nil",
            expectedErr: {{.Name | ToLower}}store.ErrDataMissing,
        },
        {{- range $testData := .GetTestDataCRUD}}
        {
            name:        "{{$testData.Name}}",
            actual:      {{$testData.Actual}},
            expectedErr: {{.Name | ToLower}}store.ErrDataMissing,
        },
        {{end}}
        {
            name:        "{{.Name | ToLower}} has no url",
            actual:      &{{.Name | ToLower}}store.{{.Name}}{Name: "myname"},
            expectedErr: {{.Name | ToLower}}store.ErrDataMissing,
        },
        {
            name:        "{{.Name | ToLower}} has ID",
            actual:      &{{.Name | ToLower}}store.{{.Name}}{ID: 1, Name: "myname", URL: "myurl"},
            expectedErr: {{.Name | ToLower}}store.ErrIDIsSet,
        },
        {
            name:     "success",
            actual:   &{{.Name | ToLower}}store.{{.Name}}{Name: "myname", URL: "myurl"},
            expected: &{{.Name | ToLower}}store.{{.Name}}{ID: 1, Name: "myname", URL: "myurl"},
        },
        {
            name:        "duplicate",
            actual:      &{{.Name | ToLower}}store.{{.Name}}{Name: "myname", URL: "myurl"},
            expectedErr: errors.New("UNIQUE constraint failed: repositories.url, repositories.name"),
        },
    }

    for _, testCase := range testCases {
        t.Run(testCase.name, func(t *testing.T) {
            err := testCase.actual.Create(context.Background(), db)
            checkErrors(t, testCase.expectedErr, err)
            test{{.Name}}(t, testCase.expected, testCase.actual)
        })
    }
}

func Test{{.Name}}_Read(t *testing.T) {
    if testing.Short() {
        t.Skip("long running test")
    }

    // 1. setup
    db := setup(t, "storeRead")

    defer func() {
        if err := db.Close(); err != nil {
            t.Fatalf("unable to close database connection: %v", err)
        }
    }()

    // 2. test
    testCases := []struct {
        name        string
        prepare     *{{.Name | ToLower}}store.{{.Name}}
        actual      *{{.Name | ToLower}}store.{{.Name}}
        expected    *{{.Name | ToLower}}store.{{.Name}}
        expectedErr error
    }{
        {
            name:        "{{.Name | ToLower}} is nil",
            expectedErr: {{.Name | ToLower}}store.ErrIDMissing,
        },
        {
            name:        "ID not set",
            expectedErr: {{.Name | ToLower}}store.ErrIDMissing,
            actual:      &{{.Name | ToLower}}store.{{.Name}}{},
        },
        {
            name:     "success",
            prepare:  &{{.Name | ToLower}}store.{{.Name}}{Name: "project", URL: "myproject.git"},
            actual:   &{{.Name | ToLower}}store.{{.Name}}{ID: 1},
            expected: &{{.Name | ToLower}}store.{{.Name}}{ID: 1, Name: "project", URL: "myproject.git"},
        },
    }

    for _, testCase := range testCases {
        t.Run(testCase.name, func(t *testing.T) {
            if testCase.prepare != nil {
            _ = testCase.prepare.Create(context.Background(), db)
            }

            err := testCase.actual.Read(context.Background(), db)
            checkErrors(t, testCase.expectedErr, err)
            test{{.Name}}(t, testCase.expected, testCase.actual)
        })
    }
}

func test{{.Name}}(t *testing.T, expected, actual *{{.Name | ToLower}}store.{{.Name}}) {
    t.Helper()

    if expected == nil && actual == nil {
        return
    }

    if expected != nil && actual == nil || expected == nil && actual != nil {
        return
    }

    if expected.ID != actual.ID {
        t.Errorf("expected ID %d but got %d", expected.ID, actual.ID)
    }

    if expected.Name != actual.Name {
        t.Errorf("expectade name '%s' but got '%s'", expected.Name, actual.Name)
    }

    if expected.URL != actual.URL {
        t.Errorf("expectade url '%s' but got '%s'", expected.URL, actual.URL)
    }

    if actual.CreatedAt.IsZero() {
        t.Error("created at should be greater than the zero date")
    }

    if actual.ModifiedAt.IsZero() {
        t.Error("modified at should be greater than the zero date")
    }
}

func Test{{.Name}}_Update(t *testing.T) { // nolint:funlen
    if testing.Short() {
        t.Skip("long running test")
    }

    // 1. setup
    db := setup(t, "storeUpdate")

    defer func() {
        if err := db.Close(); err != nil {
            t.Fatalf("unable to close database connection: %v", err)
        }
    }()

    // 2. test
    testCases := []struct {
        name        string
        prepare     *{{.Name | ToLower}}store.{{.Name}}
        actual      *{{.Name | ToLower}}store.{{.Name}}
        expected    *{{.Name | ToLower}}store.{{.Name}}
        expectedErr error
    }{
        {
            name:        "{{.Name | ToLower}} is nil",
            expectedErr: {{.Name | ToLower}}store.ErrDataMissing,
        },
        {
            name:        "{{.Name | ToLower}} has no name",
            actual:      &{{.Name | ToLower}}store.{{.Name}}{ID: 1, URL: "myurl"},
            expectedErr: {{.Name | ToLower}}store.ErrDataMissing,
        },
        {
            name:        "{{.Name | ToLower}} has no url",
            actual:      &{{.Name | ToLower}}store.{{.Name}}{ID: 1, Name: "myname"},
            expectedErr: {{.Name | ToLower}}store.ErrDataMissing,
        },
        {
            name:        "{{.Name | ToLower}} has no ID",
            actual:      &{{.Name | ToLower}}store.{{.Name}}{Name: "myname", URL: "myurl"},
            expectedErr: {{.Name | ToLower}}store.ErrIDMissing,
        },
        {
            name:     "success",
            prepare:  &{{.Name | ToLower}}store.{{.Name}}{Name: "init name", URL: "init url"},
            actual:   &{{.Name | ToLower}}store.{{.Name}}{ID: 1, Name: "myname", URL: "myurl"},
            expected: &{{.Name | ToLower}}store.{{.Name}}{ID: 1, Name: "myname", URL: "myurl"},
        },
        {
            name:        "not existing {{.Name | ToLower}}",
            actual:      &{{.Name | ToLower}}store.{{.Name}}{ID: 2, Name: "myname", URL: "myurl"},
            expectedErr: sql.ErrNoRows,
        },
    }

    for _, testCase := range testCases {
        t.Run(testCase.name, func(t *testing.T) {
            if testCase.prepare != nil {
                _ = testCase.prepare.Create(context.Background(), db)
                time.Sleep(1 * time.Second)
            }

            err := testCase.actual.Update(context.Background(), db)
            checkErrors(t, testCase.expectedErr, err)
            test{{.Name}}(t, testCase.expected, testCase.actual)

            if testCase.prepare != nil && testCase.actual != nil {
                if testCase.prepare.CreatedAt != testCase.actual.CreatedAt {
                    t.Errorf(
                        "expected created at '%s' but got '%s'",
                        testCase.prepare.CreatedAt.String(),
                        testCase.actual.CreatedAt.String(),
                    )
                }

                if testCase.prepare.ModifiedAt.After(testCase.actual.ModifiedAt) {
                    t.Errorf(
                        "expected modified at '%s' to be before but got '%s'",
                        testCase.prepare.ModifiedAt.String(),
                        testCase.actual.ModifiedAt.String(),
                    )
                }
            }
        })
    }
}

func Test{{.Name}}_Delete(t *testing.T) {
    if testing.Short() {
        t.Skip("long running test")
    }

    // 1. setup
    db := setup(t, "storeDelete")

    defer func() {
        if err := db.Close(); err != nil {
            t.Fatalf("unable to close database connection: %v", err)
        }
    }()

    // 2. test
    testCases := []struct {
        name        string
        prepare     *{{.Name | ToLower}}store.{{.Name}}
        actual      *{{.Name | ToLower}}store.{{.Name}}
        expectedErr error
    }{
        {
            name:        "{{.Name | ToLower}} is nil",
            expectedErr: {{.Name | ToLower}}store.ErrIDMissing,
        },
        {
            name:        "{{.Name | ToLower}} has no ID",
            actual:      &{{.Name | ToLower}}store.{{.Name}}{},
            expectedErr: {{.Name | ToLower}}store.ErrIDMissing,
        },
        {
            name:    "success",
            prepare: &{{.Name | ToLower}}store.{{.Name}}{Name: "init name", URL: "init url"},
            actual:  &{{.Name | ToLower}}store.{{.Name}}{ID: 1},
        },
    }

    for _, testCase := range testCases {
        t.Run(testCase.name, func(t *testing.T) {
            var id int
            if testCase.prepare != nil {
                err := testCase.prepare.Create(context.Background(), db)
                if err != nil {
                    t.Errorf("preparation failed: %v", err)
                    return
                }
                id = testCase.prepare.ID
            }

            err := testCase.actual.Delete(context.Background(), db)
            checkErrors(t, testCase.expectedErr, err)

            if id > 0 {
                testCase.actual = &{{.Name | ToLower}}store.{{.Name}}{ID: id}
                    err := testCase.actual.Read(context.Background(), db)
                    if !errors.Is(err, sql.ErrNoRows) {
                        t.Errorf("expected error '%v' after deletion but got '%v'", sql.ErrNoRows, err)
                    }
            }
        })
    }
}

func Test{{.Name}}_IsValid(t *testing.T) {
    testCases := []struct {
        name     string
        actual   *{{.Name | ToLower}}store.{{.Name}}
        expected bool
    }{
        {
            name:     "{{.Name | ToLower}} is nil",
            expected: false,
        },
        {
            name:     "only id is set",
            actual:   &{{.Name | ToLower}}store.{{.Name}}{ID: 123},
            expected: false,
        },
        {
            name:     "name missing",
            actual:   &{{.Name | ToLower}}store.{{.Name}}{ID: 123, URL: "test"},
            expected: false,
        },
        {
            name:     "url missing",
            actual:   &{{.Name | ToLower}}store.{{.Name}}{ID: 123, Name: "test"},
            expected: false,
        },
        {
            name:     "all data",
            actual:   &{{.Name | ToLower}}store.{{.Name}}{ID: 123, Name: "test", URL: "test"},
            expected: true,
        },
    }

    for _, testCase := range testCases {
        t.Run(testCase.name, func(t *testing.T) {
            res := testCase.actual.IsValid()
            if testCase.expected != res {
                t.Errorf("expected %t but got %t", testCase.expected, res)
            }
        })
    }
}

func checkErrors(t *testing.T, expected, actual error) {
    t.Helper()

    if errors.Is(actual, expected) {
        return
    }

    if expected != nil && actual != nil {
        if expected.Error() != actual.Error() {
            t.Errorf("expected error '%v' but got '%v'", expected, actual)
        }

        return
    }

    t.Errorf("expected error '%v' but got '%v'", expected, actual)
}
{{end}}
