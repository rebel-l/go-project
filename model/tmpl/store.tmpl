{{define "package.go"}}// Package {{.Name | ToLower}}store contains the CRUD operations for the {{.GetSQlTableName}} on the database.
package {{.Name | ToLower}}store
{{end}}

{{define "store.go"}}{{$elems := .Attributes}}package {{.Name | ToLower}}store

import (
    "context"
    "errors"
    "time"

    {{- range $elem := .GetImports "store"}}
    "{{$elem}}"
    {{- end}}
)

var (
    // ErrIDMissing will be thrown if an ID is expected but not set.
    ErrIDMissing = errors.New("id is mandatory for this operation")

    {{if .IsIDUUID -}}// ErrCreatingID will be thrown if creating an ID failed.
    ErrCreatingID = errors.New("id creation failed"){{end}}

    // ErrIDIsSet will be thrown if no ID is expected but already set.
    ErrIDIsSet = errors.New("id should be not set for this operation, use update instead")

    // ErrDataMissing will be thrown if mandatory data is not set.
    ErrDataMissing = errors.New("no data or mandatory data missing")
)

// {{.Name}} represents the {{.Name | ToLower}} in the database.
type {{.Name}} struct {
    {{- range $elem := $elems}}
    {{$elem.GetStoreField}}
    {{- end}}
    CreatedAt  time.Time `db:"created_at"`
    ModifiedAt time.Time `db:"modified_at"`
}

// Create creates current object in the database.
func ({{.GetReceiver}} *{{.Name}}) Create(ctx context.Context, db *sqlx.DB) error {
    if !{{.GetReceiver}}.IsValid() {
        return ErrDataMissing
    }

    {{if .IsIDUUID -}}
    if !{{.GetIDEmptyComparison ""}} {
        return ErrIDIsSet
    }

    var err error

    {{.GetReceiver}}.ID, err = uuid.NewRandom()
    if err != nil {
        return fmt.Errorf("%w: %v", ErrCreatingID, err)
    }

    {{else -}}
    if {{.GetReceiver}}.ID != 0 {
        return ErrIDIsSet
    }

    {{end -}}

    q := db.Rebind(`{{.GetSQLInsert}}`)

    {{.GetExecInsert}}
    if err != nil {
        return fmt.Errorf("failed to create: %w", err)
    }

    {{if not .IsIDUUID -}}
    id, err := res.LastInsertId()
    if err != nil {
        return err
    }

    {{.GetReceiver}}.ID = int(id) // nolint: godox TODO: use int64 to avoid type conversion

    {{end -}}

    return {{.GetReceiver}}.Read(ctx, db)
}

// Read sets the {{.Name | ToLower}} from database by given ID.
func ({{.GetReceiver}} *{{.Name}}) Read(ctx context.Context, db *sqlx.DB) error {
    if {{.GetReceiver}} == nil || {{.GetIDEmptyComparison ""}} {
        return ErrIDMissing
    }

    q := db.Rebind(`SELECT {{.Attributes.GetSQLFieldNames}}, created_at, modified_at FROM {{.GetSQlTableName}} WHERE id = ?`)
    if err := db.GetContext(ctx, {{.GetReceiver}}, q, {{.GetReceiver}}.ID); err != nil {
        return fmt.Errorf("failed to read: %w", err)
    }

    return nil
}

// Update changes the current object on the database by ID.
func ({{.GetReceiver}} *{{.Name}}) Update(ctx context.Context, db *sqlx.DB) error {
    if !{{.GetReceiver}}.IsValid() {
        return ErrDataMissing
    }

    if {{.GetIDEmptyComparison ""}} {
        return ErrIDMissing
    }

    q := db.Rebind(`{{.GetSQLUpdate}}`)

    if _, err := db.ExecContext(ctx, q, {{.GetStructFieldsWithIDLast}}); err != nil {
        return fmt.Errorf("failed to update: %w", err)
    }

    return {{.GetReceiver}}.Read(ctx, db)
}

// Delete removes the current object from database by its ID.
func ({{.GetReceiver}} *{{.Name}}) Delete(ctx context.Context, db *sqlx.DB) error {
    if {{.GetReceiver}} == nil || {{.GetIDEmptyComparison ""}} {
        return ErrIDMissing
    }

    q := db.Rebind(`DELETE FROM {{.GetSQlTableName}} WHERE id = ?`)

    if _, err := db.ExecContext(ctx, q, {{.GetReceiver}}.ID); err != nil {
        return fmt.Errorf("failed to delete: %w", err)
    }

    return nil
}

// IsValid returns true if all mandatory fields are set.
func ({{.GetReceiver}} *{{.Name}}) IsValid() bool {
    if {{.GetReceiver}} == nil || {{.GetValidationWithoutID}} {
        return false
    }

    return true
}
{{end}}

{{define "store_test.go"}}package {{.Name | ToLower}}store_test

import (
    "context"
    "database/sql"
    "errors"
    "os"
    "path/filepath"
    "testing"
    "time"

    {{- range $elem := .GetImports "store_test"}}
    "{{$elem}}"
    {{- end}}

    _ "github.com/mattn/go-sqlite3"
)

func setup(t *testing.T, name string) *sqlx.DB {
    t.Helper()

    // 0. init path
    storagePath := filepath.Join(".", "..", "..", "storage", "test_{{.Name | ToLower}}", name)

    // nolint: godox
    // TODO: change that it works with other dialects like postgres
    scriptPath := filepath.Join(".", "..", "..", "scripts", "sql", "sqlite")
    conf := &config.Database{
        StoragePath:       &storagePath,
        SchemaScriptsPath: &scriptPath,
    }

    // 1. clean up
    if osutils.FileOrPathExists(conf.GetStoragePath()) {
        if err := os.RemoveAll(conf.GetStoragePath()); err != nil {
            t.Fatalf("failed to cleanup test files: %v", err)
        }
    }

    // 2. init database
    db, err := bootstrap.Database(conf, "0.0.0", false)
    if err != nil {
        t.Fatalf("No error expected: %v", err)
    }

    return db
}

func Test{{.Name}}_Create(t *testing.T) {
    t.Parallel()

    if testing.Short() {
        t.Skip("long running test")
    }

    // 1. setup
    db := setup(t, "storeCreate")

    t.Cleanup(func() {
        if err := db.Close(); err != nil {
            t.Fatalf("unable to close database connection: %v", err)
        }
    })

    // 2. test
    testCases := []struct {
        name        string
        actual      *{{.Name | ToLower}}store.{{.Name}}
        expected    *{{.Name | ToLower}}store.{{.Name}}
        expectedErr error
    }{
        {
            name:        "{{.Name | ToLower}} is nil",
            expectedErr: {{.Name | ToLower}}store.ErrDataMissing,
        },
        {{- range $testData := .GetTestDataCU "create"}}
        {
            name:        "{{$testData.Name}}",
            actual:      {{template "struct_test_data" $testData.Actual}},
            {{- if $testData.Expected}}
            expected: {{template "struct_test_data" $testData.Expected}},
            {{- end}}
            {{- if ne $testData.ExpectedErr ""}}
            expectedErr: {{$testData.ExpectedErr}},
            {{- end}}
        },
        {{- end}}
    }

    for _, testCase := range testCases {
        testCase := testCase
        t.Run(testCase.name, func(t *testing.T) {
            t.Parallel()

            err := testCase.actual.Create(context.Background(), db)
            testingutils.ErrorsCheck(t, testCase.expectedErr, err)

            if testCase.expectedErr == nil {
                testCase.expected.ID = testCase.actual.ID
                assert{{.Name}}(t, testCase.expected, testCase.actual)
            }
        })
    }
}

func Test{{.Name}}_Read(t *testing.T) {
    t.Parallel()

    if testing.Short() {
        t.Skip("long running test")
    }

    // 1. setup
    db := setup(t, "storeRead")

    t.Cleanup(func() {
        if err := db.Close(); err != nil {
            t.Fatalf("unable to close database connection: %v", err)
        }
    })

    // 2. test
    testCases := []struct {
        name        string
        prepare     *{{.Name | ToLower}}store.{{.Name}}
        expected    *{{.Name | ToLower}}store.{{.Name}}
        expectedErr error
    }{
        {
            name:        "{{.Name | ToLower}} is nil",
            expectedErr: {{.Name | ToLower}}store.ErrIDMissing,
        },
        {
            name:        "ID not set",
            expectedErr: {{.Name | ToLower}}store.ErrIDMissing,
        },
        {{- range $testData := .GetTestDataRD "read"}}
        {
            name:        "{{$testData.Name}}",
            prepare:      {{template "struct_test_data" $testData.Prepare}},
            {{- if $testData.Expected}}
            expected: {{template "struct_test_data" $testData.Expected}},
            {{- end}}
            {{- if ne $testData.ExpectedErr ""}}
            expectedErr: {{$testData.ExpectedErr}},
            {{- end}}
        },
        {{- end}}
    }

    for _, testCase := range testCases {
        testCase := testCase
        t.Run(testCase.name, func(t *testing.T) {
            t.Parallel()

            var id {{if .IsIDUUID}}uuid.UUID{{else}}int{{end}}
            if testCase.prepare != nil {
                if testCase.prepare.IsValid() {
                    err := testCase.prepare.Create(context.Background(), db)
                    if err != nil {
                        t.Errorf("preparation failed: %v", err)

                        return
                    }
                }
                id = testCase.prepare.ID
            }

            actual := &{{.Name | ToLower}}store.{{.Name}}{ID: id}
            err := actual.Read(context.Background(), db)
            testingutils.ErrorsCheck(t, testCase.expectedErr, err)

            if testCase.expectedErr == nil {
                testCase.expected.ID = actual.ID
                assert{{.Name}}(t, testCase.expected, actual)
            }
        })
    }
}

func assert{{.Name}}(t *testing.T, expected, actual *{{.Name | ToLower}}store.{{.Name}}) {
    t.Helper()

    if expected == nil && actual == nil {
        return
    }

    if expected != nil && actual == nil || expected == nil && actual != nil {
        t.Errorf("expected '%v' but got '%v'", expected, actual)

        return
    }

    {{range $elem := .Attributes}}
    if expected.{{$elem.Name}} != actual.{{$elem.Name}} {
        t.Errorf("expected {{$elem.Name}} {{$elem.GetFormat}} but got {{$elem.GetFormat}}", expected.{{$elem.Name}}, actual.{{$elem.Name}})
    }
    {{end}}

    if actual.CreatedAt.IsZero() {
        t.Error("created at should be greater than the zero date")
    }

    if actual.ModifiedAt.IsZero() {
        t.Error("modified at should be greater than the zero date")
    }
}

func Test{{.Name}}_Update(t *testing.T) {
    t.Parallel()

    if testing.Short() {
        t.Skip("long running test")
    }

    // 1. setup
    db := setup(t, "storeUpdate")

    t.Cleanup(func() {
        if err := db.Close(); err != nil {
            t.Fatalf("unable to close database connection: %v", err)
        }
    })

    // 2. test
    testCases := []struct {
        name        string
        prepare     *{{.Name | ToLower}}store.{{.Name}}
        actual      *{{.Name | ToLower}}store.{{.Name}}
        expected    *{{.Name | ToLower}}store.{{.Name}}
        expectedErr error
    }{
        {
            name:        "{{.Name | ToLower}} is nil",
            expectedErr: {{.Name | ToLower}}store.ErrDataMissing,
        },
        {{- range $testData := .GetTestDataCU "update"}}
        {
            name:        "{{$testData.Name}}",
            actual:      {{template "struct_test_data" $testData.Actual}},
            {{- if $testData.Prepare}}
                prepare: {{template "struct_test_data" $testData.Prepare}},
            {{- end}}
            {{- if $testData.Expected}}
                expected: {{template "struct_test_data" $testData.Expected}},
            {{- end}}
            {{- if ne $testData.ExpectedErr ""}}
                expectedErr: {{$testData.ExpectedErr}},
            {{- end}}
        },
        {{- end}}
    }

    for _, testCase := range testCases {
        testCase := testCase
        t.Run(testCase.name, func(t *testing.T) {
            t.Parallel()

            if testCase.prepare != nil {
                _ = testCase.prepare.Create(context.Background(), db)
                time.Sleep(1 * time.Second)
                testCase.actual.ID = testCase.prepare.ID
            }

            err := testCase.actual.Update(context.Background(), db)
            testingutils.ErrorsCheck(t, testCase.expectedErr, err)

            if testCase.expectedErr == nil {
                testCase.expected.ID = testCase.actual.ID
                assert{{.Name}}(t, testCase.expected, testCase.actual)
            }

            if testCase.prepare != nil && testCase.actual != nil {
                if testCase.prepare.CreatedAt != testCase.actual.CreatedAt {
                    t.Errorf(
                        "expected created at '%s' but got '%s'",
                        testCase.prepare.CreatedAt.String(),
                        testCase.actual.CreatedAt.String(),
                    )
                }

                if testCase.prepare.ModifiedAt.After(testCase.actual.ModifiedAt) {
                    t.Errorf(
                        "expected modified at '%s' to be before but got '%s'",
                        testCase.prepare.ModifiedAt.String(),
                        testCase.actual.ModifiedAt.String(),
                    )
                }
            }
        })
    }
}

func Test{{.Name}}_Delete(t *testing.T) {
    t.Parallel()

    if testing.Short() {
        t.Skip("long running test")
    }

    // 1. setup
    db := setup(t, "storeDelete")

    t.Cleanup(func() {
        if err := db.Close(); err != nil {
            t.Fatalf("unable to close database connection: %v", err)
        }
    })

    // 2. test
    testCases := []struct {
        name        string
        prepare     *{{.Name | ToLower}}store.{{.Name}}
        expectedErr error
    }{
        {
            name:        "{{.Name | ToLower}} is nil",
            expectedErr: {{.Name | ToLower}}store.ErrIDMissing,
        },
        {
            name:        "{{.Name | ToLower}} has no ID",
            expectedErr: {{.Name | ToLower}}store.ErrIDMissing,
        },
        {{- range $testData := .GetTestDataRD "delete"}}
        {
            name: "{{$testData.Name}}",
            prepare: {{template "struct_test_data" $testData.Prepare}},
            {{- if ne $testData.ExpectedErr ""}}
            expectedErr: {{$testData.ExpectedErr}},
            {{- end}}
        },
        {{- end}}
    }

    for _, testCase := range testCases {
        testCase := testCase
        t.Run(testCase.name, func(t *testing.T) {
            t.Parallel()

            var id {{if .IsIDUUID}}uuid.UUID{{else}}int{{end}}
            if testCase.prepare != nil {
                if testCase.prepare.IsValid() {
                    err := testCase.prepare.Create(context.Background(), db)
                    if err != nil {
                        t.Errorf("preparation failed: %v", err)

                        return
                    }
                }
                id = testCase.prepare.ID
            }

            actual := &{{.Name | ToLower}}store.{{.Name}}{ID: id}
            err := actual.Delete(context.Background(), db)
            testingutils.ErrorsCheck(t, testCase.expectedErr, err)

            if {{if .IsIDUUID}}!uuidutils.IsEmpty(id){{else}}id > 0{{end}} {
                err := actual.Read(context.Background(), db)
                if !errors.Is(err, sql.ErrNoRows) {
                    t.Errorf("expected error '%v' after deletion but got '%v'", sql.ErrNoRows, err)
                }
            }
        })
    }
}

func Test{{.Name}}_IsValid(t *testing.T) {
    t.Parallel()

    testCases := []struct {
        name     string
        actual   *{{.Name | ToLower}}store.{{.Name}}
        expected bool
    }{
        {
            name:     "{{.Name | ToLower}} is nil",
            expected: false,
        },
        {{- range $testData := .GetTestIsValid}}
        {
            name:     "{{$testData.Name}}",
            actual:   {{template "struct_test_data" $testData.Actual}},
            expected: {{$testData.Expected}},
        },
        {{- end}}
    }

    for _, testCase := range testCases {
        testCase := testCase
        t.Run(testCase.name, func(t *testing.T) {
            t.Parallel()

            res := testCase.actual.IsValid()
            if testCase.expected != res {
                t.Errorf("expected %t but got %t", testCase.expected, res)
            }
        })
    }
}
{{end}}

{{define "struct_test_data"}}&{{.Name | ToLower}}store.{{.Name}}{
    {{- range $i, $elem := .Attributes}}{{if ne $elem.TestData ""}}
        {{$elem.GetTestDataForStruct $elem.TestData}},
    {{- end}}{{- end}}
}{{end}}
